"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[86],{8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}},8779:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"module2/chapter3","title":"Chapter 3: Spring-Loaded Inverted Pendulum (SLIP) Models","description":"3.1 Introduction to SLIP Models","source":"@site/docs/module2/chapter3.md","sourceDirName":"module2","slug":"/module2/chapter3","permalink":"/ai-native-book/docs/module2/chapter3","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Zero Moment Point (ZMP) Control and Balance","permalink":"/ai-native-book/docs/module2/chapter2"},"next":{"title":"Chapter 4: Locomotion Planning and Stability Margins","permalink":"/ai-native-book/docs/module2/chapter4"}}');var o=t(4848),a=t(8453);const s={},l="Chapter 3: Spring-Loaded Inverted Pendulum (SLIP) Models",r={},d=[{value:"3.1 Introduction to SLIP Models",id:"31-introduction-to-slip-models",level:2},{value:"3.2 Dynamics of the SLIP Model",id:"32-dynamics-of-the-slip-model",level:2},{value:"3.2.1 Stance Phase",id:"321-stance-phase",level:3},{value:"3.2.2 Flight Phase",id:"322-flight-phase",level:3},{value:"3.3 Gait Generation with SLIP Models",id:"33-gait-generation-with-slip-models",level:2},{value:"3.4 Advantages and Limitations",id:"34-advantages-and-limitations",level:2},{value:"3.5 Conclusion",id:"35-conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"chapter-3-spring-loaded-inverted-pendulum-slip-models",children:"Chapter 3: Spring-Loaded Inverted Pendulum (SLIP) Models"})}),"\n",(0,o.jsx)(n.h2,{id:"31-introduction-to-slip-models",children:"3.1 Introduction to SLIP Models"}),"\n",(0,o.jsx)(n.p,{children:"While the ZMP-based control offers a robust framework for humanoid balance, simplified dynamic models can provide deeper insights into the underlying principles of locomotion and greatly assist in gait pattern generation. The Spring-Loaded Inverted Pendulum (SLIP) model is one such powerful abstraction, particularly useful for understanding the dynamics of running, hopping, and agile walking."}),"\n",(0,o.jsx)(n.p,{children:"The SLIP model represents the robot's body as a point mass (M) at the hip, with a massless leg that can extend and compress like a spring. The leg is typically assumed to be prismatic, with a spring and damper, capable of rotating around the hip attachment point. This simple model captures key dynamics of locomotion, such as ground contact and propulsion."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Diagram"}),": Schematic of the SLIP model during stance phase (refer to image ",(0,o.jsx)(n.code,{children:"assets/module2/slip_model_schematic.png"}),")"]}),"\n",(0,o.jsx)(n.h2,{id:"32-dynamics-of-the-slip-model",children:"3.2 Dynamics of the SLIP Model"}),"\n",(0,o.jsx)(n.p,{children:"The motion of the SLIP model is typically divided into two phases: the stance phase (when the leg is in contact with the ground) and the flight phase (when the leg is not in contact). During the stance phase, the point mass moves along an arc as the spring compresses and extends, interacting with the ground reaction force."}),"\n",(0,o.jsx)(n.h3,{id:"321-stance-phase",children:"3.2.1 Stance Phase"}),"\n",(0,o.jsx)(n.p,{children:"In the stance phase, the spring compresses upon ground contact, storing energy, and then extends to propel the body forward. The equations of motion during stance are derived from the spring force, gravity, and the geometry of the inverted pendulum."}),"\n",(0,o.jsx)(n.h3,{id:"322-flight-phase",children:"3.2.2 Flight Phase"}),"\n",(0,o.jsx)(n.p,{children:"During the flight phase, the body moves as a projectile under gravity, and the leg reorients itself for the next ground contact. The dynamics are simpler during this phase as there are no ground reaction forces."}),"\n",(0,o.jsx)(n.h2,{id:"33-gait-generation-with-slip-models",children:"3.3 Gait Generation with SLIP Models"}),"\n",(0,o.jsx)(n.p,{children:"SLIP models are extensively used for generating various gaits for legged robots, including humanoids. By controlling parameters such as leg angle at touchdown, spring stiffness, and desired apex height, different locomotion behaviors can be achieved."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example: Simple SLIP Simulation (Conceptual Python)"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\nimport matplotlib.pyplot as plt\n\ndef simulate_slip_stance(initial_state, k_spring, mass, leg_length_eq, dt, total_time):\n    # Simplified conceptual simulation of SLIP stance phase\n    # In a real simulation, this would involve integrating differential equations\n    # For this example, we\'ll just show the concept of state evolution\n\n    t = np.arange(0, total_time, dt)\n    x, y, vx, vy = initial_state\n\n    # Placeholder for actual dynamic integration\n    # Here, you would calculate forces and update position/velocity\n\n    # For illustrative purposes, let\'s just simulate some basic motion\n    # This is NOT a correct dynamic simulation, just an example structure\n    positions = []\n    for _ in t:\n        # Simulate spring compression/extension, gravitational effects\n        # update x, y, vx, vy\n        positions.append((x, y))\n        x += vx * dt\n        y += vy * dt - 0.5 * 9.81 * dt**2 # Simple projectile for y\n\n    return np.array(positions)\n\n# Initial state (x, y, vx, vy)\ninitial_state = [0, 1.0, 1.0, 0]\npositions = simulate_slip_stance(initial_state, k_spring=1000, mass=10, leg_length_eq=1.0, dt=0.01, total_time=1.0)\n\n# plt.plot(positions[:, 0], positions[:, 1])\n# plt.xlabel("X Position")\n# plt.ylabel("Y Position")\n# plt.title("Conceptual SLIP Stance Phase")\n# plt.grid(True)\n# plt.show()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"34-advantages-and-limitations",children:"3.4 Advantages and Limitations"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Simplifies complex humanoid dynamics, allowing for analytical solutions."}),"\n",(0,o.jsx)(n.li,{children:"Captures the fundamental energy exchange between potential and kinetic energy during locomotion."}),"\n",(0,o.jsx)(n.li,{children:"Useful for high-speed and agile maneuvers like running and hopping."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Limitations"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Ignores upper body dynamics and arm swing, which are important for humanoid balance."}),"\n",(0,o.jsx)(n.li,{children:"Assumes a fixed leg stiffness, which may not be realistic for adaptable humanoids."}),"\n",(0,o.jsx)(n.li,{children:"Does not directly account for joint limits or multi-segment leg structures."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"35-conclusion",children:"3.5 Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"SLIP models provide a valuable tool for conceptualizing and designing dynamic gaits for humanoid robots. Despite their simplifications, they offer profound insights into the mechanics of bipedal locomotion. Understanding SLIP dynamics is essential for developing controllers that can achieve robust and energy-efficient walking and running. The next chapter will build on these concepts to discuss locomotion planning and stability margins in more detail."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);