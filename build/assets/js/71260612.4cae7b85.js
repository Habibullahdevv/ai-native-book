"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[648],{1873:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"module2/chapter1","title":"Chapter 1: Gait Generation: Kinematics and Dynamics","description":"1.1 Introduction to Humanoid Gait","source":"@site/docs/module2/chapter1.md","sourceDirName":"module2","slug":"/module2/chapter1","permalink":"/ai-native-book/docs/module2/chapter1","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: Human Locomotion, Balance, and Control in Humanoid Robotics","permalink":"/ai-native-book/docs/module2/"},"next":{"title":"Chapter 2: Zero Moment Point (ZMP) Control and Balance","permalink":"/ai-native-book/docs/module2/chapter2"}}');var t=i(4848),a=i(8453);const r={},s="Chapter 1: Gait Generation: Kinematics and Dynamics",c={},d=[{value:"1.1 Introduction to Humanoid Gait",id:"11-introduction-to-humanoid-gait",level:2},{value:"1.2 Kinematics of Humanoid Robots",id:"12-kinematics-of-humanoid-robots",level:2},{value:"1.2.1 Forward Kinematics",id:"121-forward-kinematics",level:3},{value:"1.2.2 Inverse Kinematics",id:"122-inverse-kinematics",level:3},{value:"1.3 Dynamics of Humanoid Robots",id:"13-dynamics-of-humanoid-robots",level:2},{value:"1.3.1 Lagrangian Dynamics",id:"131-lagrangian-dynamics",level:3},{value:"1.3.2 Newton-Euler Dynamics",id:"132-newton-euler-dynamics",level:3},{value:"1.4 Trajectory Generation",id:"14-trajectory-generation",level:2},{value:"1.5 Conclusion",id:"15-conclusion",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-1-gait-generation-kinematics-and-dynamics",children:"Chapter 1: Gait Generation: Kinematics and Dynamics"})}),"\n",(0,t.jsx)(n.h2,{id:"11-introduction-to-humanoid-gait",children:"1.1 Introduction to Humanoid Gait"}),"\n",(0,t.jsx)(n.p,{children:"Humanoid robots, designed to mimic human form and function, require sophisticated control strategies to achieve stable and efficient bipedal locomotion. Gait generation is the process of planning a sequence of movements for the robot's limbs and body to achieve walking. This involves understanding both the kinematics (the geometry of motion without considering forces) and dynamics (the study of forces and their effects on motion) of the robot."}),"\n",(0,t.jsx)(n.h2,{id:"12-kinematics-of-humanoid-robots",children:"1.2 Kinematics of Humanoid Robots"}),"\n",(0,t.jsx)(n.p,{children:"Kinematics focuses on the spatial configuration of the robot, including joint angles, link lengths, and end-effector positions. For humanoid robots, forward kinematics calculates the position and orientation of the end-effectors (e.g., feet, hands) given the joint angles, while inverse kinematics determines the joint angles required to achieve a desired end-effector pose."}),"\n",(0,t.jsx)(n.h3,{id:"121-forward-kinematics",children:"1.2.1 Forward Kinematics"}),"\n",(0,t.jsx)(n.p,{children:"Forward kinematics for a humanoid robot can be represented using Denavit-Hartenberg (D-H) parameters or product of exponentials (POE) formula. The transformation matrices from each joint to the next are multiplied to get the final end-effector pose."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: Simple 2-DOF Leg Segment"})}),"\n",(0,t.jsx)(n.p,{children:"Consider a simplified 2-DOF leg with thigh and shank. The transformation from the hip to the foot can be calculated as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\ndef dh_matrix(alpha, a, d, theta):\n    return np.array([\n        [np.cos(theta), -np.sin(theta)*np.cos(alpha), np.sin(theta)*np.sin(alpha), a*np.cos(theta)],\n        [np.sin(theta), np.cos(theta)*np.cos(alpha), -np.cos(theta)*np.sin(alpha), a*np.sin(theta)],\n        [0, np.sin(alpha), np.cos(alpha), d],\n        [0, 0, 0, 1]\n    ])\n\n# Assuming simplified DH parameters for two links\n# Link 1: alpha=0, a=L1, d=0, theta=q1 (thigh rotation)\n# Link 2: alpha=0, a=L2, d=0, theta=q2 (shank rotation)\n\nL1 = 0.5  # Thigh length\nL2 = 0.4  # Shank length\nq1 = np.pi/4 # Thigh angle\nq2 = np.pi/6 # Shank angle\n\nT01 = dh_matrix(0, L1, 0, q1)\nT12 = dh_matrix(0, L2, 0, q2)\n\nT02 = np.dot(T01, T12) # Transformation from hip to foot\n\nprint("Foot position (x, y, z):", T02[:3, 3])\n'})}),"\n",(0,t.jsx)(n.h3,{id:"122-inverse-kinematics",children:"1.2.2 Inverse Kinematics"}),"\n",(0,t.jsx)(n.p,{children:"Inverse kinematics is more complex, often requiring iterative numerical methods or geometric solutions for simpler structures. For humanoid robots, real-time inverse kinematics is crucial for adapting to terrain and maintaining balance."}),"\n",(0,t.jsx)(n.h2,{id:"13-dynamics-of-humanoid-robots",children:"1.3 Dynamics of Humanoid Robots"}),"\n",(0,t.jsx)(n.p,{children:"Dynamics deals with the forces and torques that cause motion. For humanoid gait, understanding gravity, ground reaction forces, and inertial forces is essential for stable control. Lagrangian or Newton-Euler formulations are commonly used."}),"\n",(0,t.jsx)(n.h3,{id:"131-lagrangian-dynamics",children:"1.3.1 Lagrangian Dynamics"}),"\n",(0,t.jsx)(n.p,{children:"The Lagrangian approach focuses on the robot's kinetic and potential energy to derive equations of motion. It's particularly useful for complex multi-link systems."}),"\n",(0,t.jsx)(n.h3,{id:"132-newton-euler-dynamics",children:"1.3.2 Newton-Euler Dynamics"}),"\n",(0,t.jsx)(n.p,{children:"Newton-Euler provides a recursive method to calculate forces and torques, moving from the base to the end-effectors (forward recursion) and then back (backward recursion). This is often preferred for real-time control due to its computational efficiency."}),"\n",(0,t.jsx)(n.h2,{id:"14-trajectory-generation",children:"1.4 Trajectory Generation"}),"\n",(0,t.jsx)(n.p,{children:"Once the kinematics and dynamics are understood, desired trajectories for joints and end-effectors can be generated. This often involves polynomials or splines to ensure smooth and continuous motion."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Diagram"}),": Example of a humanoid robot's kinematic chain (refer to image ",(0,t.jsx)(n.code,{children:"assets/module2/kinematic_chain.png"}),")"]}),"\n",(0,t.jsx)(n.h2,{id:"15-conclusion",children:"1.5 Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"Gait generation relies heavily on a thorough understanding of humanoid kinematics and dynamics. By accurately modeling the robot's physical properties and motion capabilities, we lay the groundwork for developing robust balance and control strategies, which will be explored in subsequent chapters."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var o=i(6540);const t={},a=o.createContext(t);function r(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);